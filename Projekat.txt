-Pocetni kod(omogucavanje unosa):

REC = 'PLANE'
Pogodi = input("Guess a word: ")
if Pogodi == REC:
    print("Correct")
else:
    print("Wrong")

-Korisnik moze da unese tacnu rec, ali program nece prepoznati tu rec kao tacnu ako korisnik ne napise tu rec kao sto je zamisljeno u programu. 
(npr. Tacna rec je 'PLANE', ako korisnik unese 'plane' program nece priznati tu rec kao tacnu)
Resenje: Pretvaramo korisnicki input u uppercase sa .upper().

Pogodi = input("Guess {guess_num} ").upper()

-Dodavanje petlje(wordle daje korisniku 6 pokusaja da pogodi rec):

REC = 'PLANE'

for br_pog in range (1, 7):
    Pogodi = input("Guess a word: ").upper()
    if Pogodi == REC:
        print("Correct")
        break
    else:
        print("Wrong")

-Proveravanje tacnosti korisnickog unosa:

Odredjujemo tacno postavljena slova uz pomoc funkcije zip(), ova funckija je odlicna za uporedjivanje slova dva stringa.

Primer:

for tacno_slovo, pogodjeno in zip(Rec, Pogodi):
            if tacno_slovo == pogodjeno:
                print(tacno_slovo)

Tacno postavljena slova mozemo odrediti na bolji nacin kombinovanjem zip() funkc. i "comprehensions", koje se moze koristiti za kreiranje mocne funkcionalnosti unutar jedne linije koda.
Ovde cemo koristiti "set comprehensions".

Primer:tacna_slova={slovo for slovo, tacno in zip(Pogodi, REC) if slovo == tacno}

Netacna slova odredjujemo pomocu setova: set(Rec) - set(Pogodi)

Slova koja su pogodjena ali nisu na svom mestu odredjujemo: set(guess) & set(WORD) - tacna_slova
set(guess) & set(WORD) odredjuje zajednicka slova i oduzimanjem tacnih slova dobijamo samo ona slova koja su tacna a nisu na svom mestu.

-Trenutni kod:

REC = 'PLANE'

for br_pog in range (1, 7):
    Pogodi = input("Guess {br_pog}: ").upper()
    if Pogodi == REC:
        print("Correct")
        break
    tacna_slova = {slovo for slovo, correct in zip(Pogodi, REC) if slovo == correct}
    slova_van_mesta = set(Pogodi) & set(REC) - tacna_slova
    pogresna = set(Pogodi) - set(REC)
    
    print("Correct letters:", ", ".join(sorted(tacna_slova)))
    print("Misplaced letters:", ", ".join(sorted(slova_van_mesta)))
    print("Wrong letters:", ", ".join(sorted(pogresna)))

-Lista reci:
Pravimo listu reci iz koje ce program nasumicno birati resenja.
Ovde koristimo biblioteku "pathlib". Koristimo funkciju .read_text(): "opens the path in text mode and returns the contents as a string".
.read_text() sadrzaj .txt file-a vraca kao jedan string (npr. bench\nbdult\namong\navoid\nafter\nanger\naward\nbirth\nagain\nangle\n)

Koristimo strip() kako bi smo uklonili zadnji \n (newline) i split(\n) kako bi smo razdvojili reci i napravili listu.

-Nasumicni odabir:
Koristimo biblioteku "random" i funkciju .choice().

-Trenutni kod:

import pathlib
import random

LISTARECI = pathlib.Path("lista_reci.txt")
reci = [
    rec.upper()
    for rec in LISTARECI.read_text(encoding="utf-8").strip().split("\n")
]
rec = random.choice(reci)
for br_pog in range (1, 7):
    Pogodi = input("\nGuess a word:").upper()
    if Pogodi == rec:
        print("Correct")
        break
    tacna_slova = {slovo for slovo, tacno in zip(Pogodi, rec) if slovo == tacno}
    slova_van_mesta = set(Pogodi) & set(rec) - tacna_slova
    pogresna = set(Pogodi) - set(rec)
    
    print("Correct letters:", ", ".join((tacna_slova)))
    print("Misplaced letters:", ", ".join((slova_van_mesta)))
    print("Wrong letters:", ", ".join((pogresna)))
else:
    print("\nThe word was", rec)

-Filtriranje reci iz liste:
Koristimo funkciju if, proveravamo duzinu reci len(rec)==5 i trazimo reci koja koriste abecedu (A-Z).

Kod:
import pathlib
import random
from string import ascii_letters


LISTARECI = pathlib.Path("reciii.txt") #ucitava listu
reci = [
    rec.upper() #forsira uppercase
    for rec in LISTARECI.read_text(encoding="utf-8").split("\n")
    if len(rec) == 5 and all(slovo in ascii_letters for slovo in rec) #filtriranje
]
...
Sklonili smo funkciju strip() zato sto se filtriranjem sklanja "\n". 

-Organizovanje koda uz pomoc funkcija:

Pravimo dve funkcije: random_rec() i proveri()
Kod:
import pathlib
import random
from string import ascii_letters

def random_rec():
    LISTARECI = pathlib.Path("reciii.txt")
    reci = [
        rec.upper() #forsira uppercase
        for rec in LISTARECI.read_text(encoding="utf-8").split("\n")
        if len(rec) == 5 and all(slovo in ascii_letters for slovo in rec) #filtriranje
    ]
    return random.choice(reci)

def proveri(Pogodi, rec):
    tacna_slova = {slovo for slovo, tacno in zip(Pogodi, rec) if slovo == tacno}
    slova_van_mesta = set(Pogodi) & set(rec) - tacna_slova
    pogresna = set(Pogodi) - set(rec)
    
    print("Correct letters:", ", ".join((tacna_slova)))
    print("Misplaced letters:", ", ".join((slova_van_mesta)))
    print("Wrong letters:", ", ".join((pogresna)))

def main():
    rec = random_rec()
    br = 7
    for br_pog in range (1, 7):
        print("\nYou have ",br-1, "chances to guess the correct word.")
        Pogodi = input("\nGuess a word:").upper()

        
        proveri(Pogodi, rec)
        if Pogodi==rec:
            break
    else:
        print("\nThe word was", rec)

if __name__ == "__main__":
    main()

-Vizuelizacija:

Biblioteka "Rich" (https://rich.readthedocs.io/en/stable/index.html)
Koristi se za poboljsanje TUI(text user interface).
Ovde menjamo funkciju promeni, dodajemo funkciju obrisi i funkciju kraj_igre.
Funkcija obrisi ce posle svakog unosa da brise prikaz prethodnog unosa.
Funkcija kraj igre ce ispisati odredjenu poruku u zavisnosti od toga da li je rec pogodjena ili nije.

Kod:
import pathlib
import random
from string import ascii_letters
from rich.console import Console # type: ignore
console = Console(width=60)

def obrisi(naslov): #brisemo sadrzaj ekrana nakon svakog pokusaja
    console.clear()
    console.rule(f"[bold blue] {naslov} [/]\n")

def random_rec():
    LISTARECI = pathlib.Path("lista_reci.txt")
    reci = [
        rec.upper() #forsira uppercase
        for rec in LISTARECI.read_text(encoding="utf-8").split("\n")
        if len(rec) == 5 and all(slovo in ascii_letters for slovo in rec) #filtriranje
    ]
    return random.choice(reci)

def proveri(pokusaji, rec):
    for pokusaj in pokusaji:
        styled_guess = []
        for slovo, tacno in zip(pokusaj, rec):
            if slovo == tacno:
                vizuelizacija = "bold white on green"
            elif slovo in rec:
                vizuelizacija = "bold white on yellow"
            elif slovo in ascii_letters:
                vizuelizacija = "white on #666666"
            else:
                vizuelizacija = "dim"
            styled_guess.append(f"[{vizuelizacija}]{slovo}[/]")

        console.print(" ".join(styled_guess), justify="center")
        
def kraj_igre(pokusaji, rec, tacno):
    obrisi(naslov= "Game Over") # type: ignore
    proveri(pokusaji, rec)
    
    if tacno:
        console.print(f"\n[bold white on green]Correct, the word is {rec}[/]")
    else:
        console.print(f"\n[bold white on red]Incorrect, the word was {rec}[/]")

def main():
    rec = random_rec()
    pokusaji=['_' * 5] * 6 #menjamo u listu kako bi smo pratili korisnicke pokusaje 
    for i in range (6):
        obrisi(naslov=f"Guess {i + 1}")
        proveri(pokusaji, rec)

        pokusaji[i] = input("\nGuess word: ").upper()

        
        proveri(pokusaji, rec)
        if pokusaji[i]==rec:
            break

    kraj_igre(pokusaji, rec, tacno=pokusaji[i]==rec)

if __name__ == "__main__":
    main()

-Kako bi smo bolje ispitali korisnicki unos pogadjanje reci prebacujemo u funkciju:

def pogadjanje(prethodni_unos):
    pogodi=input("\nGuess a word: ").upper()
    
    if pogodi in prethodni_unos:
        print(f"You've already guessed {pogodi}.")
        return pogadjanje(prethodni_unos)
    
    if len(pogodi) != 5:
        print("Your guess must be 5 letters.")
        return pogadjanje(prethodni_unos)
    
    if any((invalid := slovo) not in ascii_letters for slovo in pogodi):
        print(f"Invalid letter: {invalid}.")
        return pogadjanje(prethodni_unos)
    
    return pogodi
Funkcija ispituje da li smo vec jednom uneli rec (zato nam i treba prethodni unos)
	 ispituje da li rec sadrzi nedozvoljne karaktere
	 i ispituje da li je uneta rec sadrzi pet slova.

Zavrsni kod:

import pathlib
import random
from string import ascii_letters
from rich.console import Console # type: ignore
console = Console(width=70)

def obrisi(naslov): #brisemo sadrzaj ekrana nakon svakog pokusaja
    console.clear()
    console.rule(f"[bold blue] {naslov} [/]\n")

def random_rec():
    LISTARECI = pathlib.Path("lista_reci.txt")
    reci = [
        rec.upper() #forsira uppercase
        for rec in LISTARECI.read_text(encoding="utf-8").split("\n")
        if len(rec) == 5 and all(slovo in ascii_letters for slovo in rec) #filtriranje
    ]
    return random.choice(reci)

def proveri(pokusaji, rec):
    for pokusaj in pokusaji:
        styled_guess = []
        for slovo, tacno in zip(pokusaj, rec):
            if slovo == tacno:
                vizuelizacija = "bold white on green"
            elif slovo in rec:
                vizuelizacija = "bold white on yellow"
            elif slovo in ascii_letters:
                vizuelizacija = "white on #666666"
            else:
                vizuelizacija = "dim"
            styled_guess.append(f"[{vizuelizacija}]{slovo}[/]")

        console.print(" ".join(styled_guess), justify="center")
        
def kraj_igre(pokusaji, rec, tacno):
    obrisi(naslov= "Game Over") # type: ignore
    proveri(pokusaji, rec)
    
    if tacno:
        console.print(f"\n[bold white on green]Correct, the word is {rec}[/]")
    else:
        console.print(f"\n[bold white on red]Incorrect, the word was {rec}[/]")
        
def pogadjanje(prethodni_unos):
    pogodi=input("\nGuess a word: ").upper()
    
    if pogodi in prethodni_unos:
        print(f"You've already guessed {pogodi}.")
        return pogadjanje(prethodni_unos)
    
    if len(pogodi) != 5:
        print("Your guess must be 5 letters.")
        return pogadjanje(prethodni_unos)
    
    if any((invalid := slovo) not in ascii_letters for slovo in pogodi):
        print(f"Invalid letter: {invalid}.")
        return pogadjanje(prethodni_unos)
    
    return pogodi

def main():
    rec = random_rec()
    pokusaji=['_' * 5] * 6 #menjamo u listu kako bi smo pratili korisnicke pokusaje 
    for i in range (6):
        obrisi(naslov=f"Guess {i + 1}")
        proveri(pokusaji, rec)

        pokusaji[i] = pogadjanje(prethodni_unos=pokusaji[:i])

        if pokusaji[i]==rec:
            break

    kraj_igre(pokusaji, rec, tacno=pokusaji[i]==rec)

if __name__ == "__main__":
    main()
